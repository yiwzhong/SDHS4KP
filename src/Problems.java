

import java.io.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;

/**
 * @author yiwen zhong
 *
 */

public class Problems {
	public static Problems problem = null;
	public static String fileName = null;

	//to open the file generated by myself
	private Problems(String fileName) throws FileNotFoundException,IOException {
		Problems.fileName = fileName;
       	readFile(fileName);
 	}
	
	/**
	 * The problem to be solved is:
     * Max  sum{j=1,...,n} p(j)x(j)
     * s.t. sum{j=1,...,n} w(i,j)x(j) <= b(i)       i=1,...,m
                     x(j)=0 or 1
  
 	 * The format of the data file is:
     *    number of items (n), number of dimensions (m==1 always), optimal solution value (zero if unavailable)
     *    the value of items p(j); j=1,...,n
     *    for each dimension i (i=1,...,m): the weights of items w(i,j); j=1,...,n
     *    the capacity of dimension b(i); i=1,...,m	
	 * 
	 * 
	 * @param fileName
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	private void readFile(String fileName) throws FileNotFoundException,IOException{
		FileReader data;
		Scanner scan;

		data = new FileReader(fileName);
		scan = new Scanner(data);
		itemNumber = scan.nextInt();
		scan.nextInt(); //ignore dimension
		bestValue = scan.nextDouble();
		if (bestValue == 0) {
			bestValue = Integer.MAX_VALUE;
		}
		//to read values of items
		values = new double[itemNumber];
		for (int i = 0; i < itemNumber; i++) {
			values[i] = scan.nextDouble();
		}
		
		//to read the weights of items
		weights = new double[itemNumber];
		for (int j = 0; j < itemNumber; j++) {
				weights[j] = scan.nextDouble();
		}
		
		//to read the capacity
		capacity = scan.nextDouble();

		scan.close();
		data.close();
		
		//sort items
		List<Item> list = new ArrayList<>();
		for (int index = 0; index < itemNumber; index++) {
			list.add(new Item(index, values[index], weights[index]));
		}
		Collections.sort(list);
		Collections.reverse(list); //decreasing
		densityOrder = new int[itemNumber];
		densityList = new ArrayList<>();
		for (int i = 0; i < list.size(); i++) {
			densityOrder[i] = list.get(i).getID();
			densityList.add(densityOrder[i]);
		}
		
		Collections.sort(list, Comparator.comparing( u -> u.getValue()));
		Collections.reverse(list); //decreasing
		valueOrder = new int[itemNumber];
		valueList = new ArrayList<>();
		for (int i = 0; i < list.size(); i++) {
			valueOrder[i] = list.get(i).getID();
			valueList.add(valueOrder[i]);
		}
		
		inHeuristic = new boolean[itemNumber];
		double w = 0;
		for (int idx = 0; idx < densityOrder.length & w <= capacity; idx ++) {
			int item = densityOrder[idx];
			w += weights[item];
			inHeuristic[item] = true;
		}
		
		w = 0;
		for (int idx = 0; idx < valueOrder.length & w <= capacity; idx ++) {
			int item = valueOrder[idx];
			w += weights[item];
			inHeuristic[item] = true;
		}
	}

	public static Problems getProblem() {
		if (problem == null) {
			try {
				problem = new Problems(fileName);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return problem;
	}

	public static void setFileName(String fileName) {
		Problems.fileName = fileName;
		try {
			problem = new Problems(fileName);
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}


	public String toString() {
		StringBuffer out=new StringBuffer();

		out.append(itemNumber + "\n");
		for (int i = 0; i < values.length; i++) {
			out.append(values[i]+"\t");
		}
		out.append("\n");
		
        out.append(capacity);
		out.append("\n");
		
		for (int i = 0; i < weights.length; i++) {
			out.append(weights[i]+"\t");
		}
		out.append("\n");
		out.append(bestValue);
		out.append("\n");
		
		for (int i = 0; i < densityOrder.length; i++) {
			out.append(densityOrder[i]+"\t");
		}
		out.append("\n");
				
		for (int i = 0; i < valueOrder.length; i++) {
			out.append(valueOrder[i]+"\t");
		}
		out.append("\n");
			
		return out.toString();
	}
	
	
	public int getItemNumber() { return itemNumber;}
	public double getCapacity() { return capacity;}
	public double getItemValue(int item) { return values[item];}
	public double getItemWeight(int item) { return weights[item];}
	public double getBestValue() { return bestValue;}
	public int[] getDensityOrder() { return densityOrder;}
	public int[] getValueOrder() { return valueOrder;}
	public List<Integer> getDensityList() { return densityList;}
	public List<Integer> getValueList() { return valueList;}
	
    private int itemNumber;
    
	private double[] values = null; //values of items
	private double capacity = 0; //capacities of dimensions of knapsack
	private double[] weights = null; //weight of item for each dimension of knapsack
	private double bestValue; //the best known solution
	
	private int[] densityOrder;
	private int[] valueOrder;
	private List<Integer> densityList;
	private List<Integer> valueList;
	
	public boolean[] inHeuristic = null;
	
	public static void main(String[] args) {
		String filePath = (new File("")).getAbsolutePath() + "/../f1-10/";
		fileName = filePath + "f5.txt";
		try {
			problem = new Problems(fileName);
		} catch (Exception ex) {
			ex.printStackTrace();
		}
		System.out.println(problem);
	}
}

class Item implements Comparable<Item>{
	private int id;
	private double value;
	private double density;
	
	public Item(int id, double value, double weight) {
		this.id = id;
		this.value = value;
		density = value / weight;
	}
	
	
	
	public int getID() { return id; }
	public double getValue() { return value;}
	public double getDensity() { return density; }



	@Override
	public int compareTo(Item o) {
		if (this.density > o.density) {
			return 1;
		} else if (this.density == o.density) {
			return 0;
		} else {
			return -1;
		}
	}
}

